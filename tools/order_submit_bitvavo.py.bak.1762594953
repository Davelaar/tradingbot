#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os, json, time, decimal, logging
from typing import Dict, Any
from redis import Redis
from redis.exceptions import ResponseError
from python_bitvavo_api.bitvavo import Bitvavo

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
D = decimal.Decimal

REDIS_URL   = os.getenv("REDIS_URL", "redis://127.0.0.1:6379/0")
ORDER_STREAM= os.getenv("ORDER_STREAM", "orders:live")
EXEC_STREAM = os.getenv("EXEC_STREAM",  "orders:executed")
GROUP       = os.getenv("GROUP", "trading_submitter")
CONSUMER    = os.getenv("CONSUMER", "submitter-1")
DRY         = os.getenv("DRY", "0") in ("1","true","True","YES","yes")

BV_KEY      = os.getenv("BITVAVO_API_KEY", "")
BV_SECRET   = os.getenv("BITVAVO_API_SECRET", "")
BV_OPID     = os.getenv("BITVAVO_OPERATOR_ID", "")  # <-- noodzaak

def emit_executed(r:Redis, mid:str, status:str, obj:Any):
    r.xadd(EXEC_STREAM, {"status": status, "ts": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
                         "mid": mid, "order": json.dumps(obj, separators=(",",":"))})

def parse_payload(fields: Dict[str,str]) -> Dict[str,Any]:
    # core outbox payload zit onder key 'data' (JSON string)
    raw = fields.get("data")
    if not raw:
        raise ValueError("geen 'data' veld in stream item")
    p = json.loads(raw)
    # normaliseer keys die we gebruiken
    return {
        "market":   p.get("market"),
        "side":     p.get("side","buy"),
        "orderType":p.get("orderType","market" if (p.get("price") in (None,"0.00000000","0","0.0")) else "limit"),
        "amount":   p.get("amount","0.000000"),
        "price":    p.get("price", None),
        "tp_pct":   p.get("tp_pct", "0.0000"),
        "sl_pct":   p.get("sl_pct", "0.0000"),
        "mode":     p.get("mode","percent"),
        "src":      "core_outbox_v2"
    }

def place_order_live(req: Dict[str,Any]) -> Dict[str,Any]:
    if not (BV_KEY and BV_SECRET):
        raise RuntimeError("Bitvavo credentials ontbreken")
    bv = Bitvavo({"APIKEY": BV_KEY, "APISECRET": BV_SECRET})
    body = {
        "market": req["market"],
        "side": req["side"],
        "orderType": req["orderType"],
        "amount": str(req["amount"]),
    }
    if req.get("price"):  # alleen bij limit
        body["price"] = str(req["price"])
    if BV_OPID:
        body["operatorId"] = BV_OPID  # <-- cruciaal
    # Uitvoeren
    if os.getenv("BITVAVO_OPERATOR_ID") and "operatorId" not in body:
        body["operatorId"]=os.getenv("BITVAVO_OPERATOR_ID")
    resp = bv.placeOrder(body)  # python_bitvavo_api ondersteunt dict-vorm
    return {"request": body, "response": resp}

def ensure_group(r:Redis):
    try:
        r.xgroup_create(name=ORDER_STREAM, groupname=GROUP, id="$", mkstream=True)
    except ResponseError as e:
        if "BUSYGROUP" not in str(e):
            raise

def main():
    r = Redis.from_url(REDIS_URL, decode_responses=True)
    ensure_group(r)
    logging.info("Submitter gestart | stream=%s group=%s consumer=%s live=%s",
                 ORDER_STREAM, GROUP, CONSUMER, not DRY)
    while True:
        resp = r.xreadgroup(GROUP, CONSUMER, {ORDER_STREAM: ">"}, count=10, block=5000)
        if not resp:
            continue
        for stream, items in resp:
            for mid, fields in items:
                try:
                    req = parse_payload(fields)
                    if DRY:
                        fake = {
                            "market": req["market"], "side": req["side"],
                            "orderType": req.get("orderType","auto"),
                            "amount": str(req.get("amount","auto")),
                            "price": req.get("price"),
                            "src": "core_outbox_v2"
                        }
                        emit_executed(r, mid, "DRY_OK", fake)
                    else:
                        result = place_order_live(req)
                        emit_executed(r, mid, "LIVE_OK", result)
                    r.xack(ORDER_STREAM, GROUP, mid)
                except Exception as e:
                    logging.error("ORDER EXC id=%s payload=%s err=%s",
                                  mid, json.dumps(fields)[:500], repr(e))
                    # niet ACK'en; blijft pending voor inspectie
